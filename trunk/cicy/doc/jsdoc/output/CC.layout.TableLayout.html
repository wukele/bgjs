<div xmlns:ext="http://www.extjs.com" class="body-wrap"><div class="inheritance res-block"><pre class="res-block-inner"><a href="output/CC.layout.Layout.html" ext:member="" ext:cls="CC.layout.Layout">Layout</a>&#13;&nbsp;&nbsp;<img src="resources/elbow-end.gif">TableLayout</pre></div><h1>类 <a href="source/cicylib-all.html#cls-CC.layout.TableLayout">CC.layout.TableLayout</a></h1><table cellspacing="0"><tr><td class="label">空间：</td><td class="hd-info">CC.layout</td></tr><tr><td class="label">定义在:</td><td class="hd-info">cicylib-all.js</td></tr><tr><td class="label">类:</td><td class="hd-info"><a href="source/cicylib-all.html#cls-CC.layout.TableLayout">TableLayout</a></td></tr><tr><td class="label">父类:</td><td class="hd-info"><a href="output/CC.layout.Layout.html" ext:cls="CC.layout.Layout" ext:member="">Layout</a></td></tr></table><div class="description">用HTML TABLE元素布局控件,主要用于表单设计中,
布局信息用JSON表示,通过 lyCfg:{  items:  } 传入.
items为一个数组,数组每个元素代表一行(tr).
每一行的数据格式可为一个数组或一个object
行为数组时,数组中每个元素表示每个单元(td)<br>
行为object时,表示该行只有一个单元格,可以在object中定义td,tr的属性信息, object.td = {}, object.tr = {}<br>
当一个配置信息既无ctype属性,亦无td属性时被看作是该行tr的信息
<br>
 <pre><code><b>var</b> win = <b>new</b> CC.ui.Win({
  showTo:document.body,
  layout:<em>'table'</em>,
  lyCfg:{
    <i>// 设置table结点的class样式</i>
    tblCs : <em>'form_tbl'</em>,
    <i>// 设置每个分组的信息</i>
  	group:{ 
  		cols:2,
  		<i>// 第一个colgroup结点的信息</i>
  		0 : {css:<em>'w:120'</em>, cs:<em>'hgrp'</em>} 
  	},
  	
    items:[
      <i>//  row one</i>
      [ 
        { 
          <i>// cell one</i>
          ctype:<em>'<b>label</b>'</em>, 
          title:<em>'提交请求:'</em>, 
          <i>// td结点的信息</i>
          td:{css:<em>'tr'</em>, cs:<em>'cap'</em>}
        },
         <i>// cell two</i>
        {ctype:<em>'text'</em>,  width:120, value:<em>'提交请求:'</em>}
      ],
      <i>// row two</i>
      { 
        ctype:<em>'text'</em>, css:<em>'w:100%'</em>, 
        <i>// td.colspan = 2</i>
        td:{cols:2}
      },
      
      [
        <i>// 占位td</i>
        false, 
        <i>// tr信息</i>
        {cs:<em>'tr-row'</em>}, 
        {td:{css:<em>'h:33'</em>}}
      ],
      <i>// row <b>with</b> single cell , no component</i>
      {tr:{cs:<em>'tr-end'</em>}, td:{cols:2}}
    ]
  }
});</code></pre></div><div class="hr"></div><a id="CC.layout.TableLayout-configs"></a><h2>配置项</h2><table cellspacing="0" class="member-table"><tbody><tr><th colspan="2" class="sig-header">config</th><th class="msource-header">定义在</th></tr><tr class="config-row  "><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.TableLayout-tblCs"></a><b><a href="source/cicylib-all.html#cfg-CC.layout.TableLayout-tblCs">tblCs</a></b> : String<div class="mdesc">class name of main table node</div></td><td class="msource">TableLayout</td></tr><tr class="config-row  继承自"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-ct"></a><b><a href="source/cicylib-all.html#cfg-CC.layout.Layout-ct">ct</a></b> : CC.Base<div class="mdesc">布局管理器对应的容器</div></td><td class="msource">Layout</td></tr><tr class="config-row  继承自"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-items"></a><b><a href="source/cicylib-all.html#cfg-CC.layout.Layout-items">items</a></b> : Array<div class="mdesc">初始化时由管理器加入到容器的子项列表, 该属性等同于<a href="output/CC.ui.ContainerBase.html#CC.ui.ContainerBase-items" ext:member="items" ext:cls="CC.ui.ContainerBase">CC.ui.ContainerBase.items</a>.</div></td><td class="msource">Layout</td></tr><tr class="config-row  继承自"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-layoutOnChange"></a><b><a href="source/cicylib-all.html#cfg-CC.layout.Layout-layoutOnChange">layoutOnChange</a></b> : Boolean<div class="mdesc">如果每次布局都涉及所有容器子项,则该值应设为true,以便于当容器子项变更(add, remove, display)时重新布局容器</div></td><td class="msource">Layout</td></tr><tr class="config-row  继承自"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-deffer"></a><b><a href="source/cicylib-all.html#cfg-CC.layout.Layout-deffer">deffer</a></b> : Boolean<div class="mdesc">默认false
延迟多少毫秒后再布局,有利于提高用户体验,
但注意访问同步,例如容器子项在布局时才渲染,
如果deffer已置,则子项渲染将会在JavaScript下一周期调用.</div></td><td class="msource">Layout</td></tr><tr class="config-row  继承自"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-itemCS"></a><b><a href="source/cicylib-all.html#cfg-CC.layout.Layout-itemCS">itemCS</a></b> : String<div class="mdesc">将子项被加进容器时添加到子项的CSS样式</div></td><td class="msource">Layout</td></tr><tr class="config-row expandable 继承自"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-lyInf"></a><b><a href="source/cicylib-all.html#cfg-CC.layout.Layout-lyInf">lyInf</a></b> : Object<div class="mdesc"><div class="short">布局配置数据,子项的父容器布局管理器根据该信息布局子项.&#13;
    如果控件被布局管理器所管理,其布局相关的配置信息将存放在component.lyInf,&#13;
    要访问子项当前布局信息,可通过container.layout.c...</div><div class="long">布局配置数据,子项的父容器布局管理器根据该信息布局子项.<br>
    如果控件被布局管理器所管理,其布局相关的配置信息将存放在component.lyInf,
    要访问子项当前布局信息,可通过container.layout.cfgFrom(component)方法获得.</div></div></td><td class="msource">Layout</td></tr><tr class="config-row expandable 继承自"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-invalidate"></a><b><a href="source/cicylib-all.html#cfg-CC.layout.Layout-invalidate">invalidate</a></b> : Boolean<div class="mdesc"><div class="short">指示当引发布局时是否执行布局,&#13;
如大量引发重复布局的操作可先设置invalidate=true,执行完后再设置invalidate=false,&#13;
再调用doLayout布局.&#13;
容器类不必直接设置该属性,&#13;
可调用CC.ui.Co...</div><div class="long">指示当引发布局时是否执行布局,
如大量引发重复布局的操作可先设置invalidate=true,执行完后再设置invalidate=false,
再调用<a href="output/CC.layout.Layout.html#CC.layout.Layout-doLayout" ext:member="doLayout" ext:cls="CC.layout.Layout">doLayout</a>布局.<br>
容器类不必直接设置该属性,
可调用<a href="output/CC.ui.ContainerBase.html#CC.ui.ContainerBase-validate" ext:member="validate" ext:cls="CC.ui.ContainerBase">CC.ui.ContainerBase.validate</a>和<a href="output/CC.ui.ContainerBase.html#CC.ui.ContainerBase-invalidate" ext:member="invalidate" ext:cls="CC.ui.ContainerBase">CC.ui.ContainerBase.invalidate</a>方法.</div></div></td><td class="msource">Layout</td></tr><tr class="config-row  继承自"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-ctCS"></a><b><a href="source/cicylib-all.html#cfg-CC.layout.Layout-ctCS">ctCS</a></b> : String<div class="mdesc">初始化时添加到容器的样式</div></td><td class="msource">Layout</td></tr><tr class="config-row  继承自"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-wrCS"></a><b><a href="source/cicylib-all.html#cfg-CC.layout.Layout-wrCS">wrCS</a></b> : String<div class="mdesc">初始化时添加到容器ct.wrapper的样式</div></td><td class="msource">Layout</td></tr></tbody></table><a id="CC.layout.TableLayout-props"></a><h2>公共属性（只读）</h2><table cellspacing="0" class="member-table"><tbody><tr><th colspan="2" class="sig-header">properties</th><th class="msource-header">定义在</th></tr><tr class="property-row  "><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.TableLayout-tableEl"></a><b><a href="source/cicylib-all.html#prop-CC.layout.TableLayout-tableEl">tableEl</a></b> : HTMLElement<div class="mdesc"></div></td><td class="msource">TableLayout</td></tr></tbody></table><a id="CC.layout.TableLayout-events"></a><h2>事件列表</h2><div class="no-members">This class has no public events.</div><a id="CC.layout.TableLayout-methods"></a><h2>公共方法</h2><table cellspacing="0" class="member-table"><tbody><tr><th colspan="2" class="sig-header">method</th><th class="msource-header">定义在</th></tr><tr class="method-row expandable inherited"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-add"></a><b><a href="source/cicylib-all.html#method-CC.layout.Layout-add">add</a></b>(&nbsp;<code>CC.Base&nbsp;component</code>,&nbsp;<code>Object&nbsp;cfg</code>&nbsp;)
    :
                                        this<div class="mdesc"><div class="short">将组件 component 添加到布局,&#13;
如果容器具有有效的布局管理器,则建议从布局管理器添加子项组件,&#13;
而不是直接调用容器add方法, 其它子项变更操作(remove, insert)同理.&#13;
如果layoutOnChange为...</div><div class="long">将组件 component 添加到布局,
如果容器具有有效的布局管理器,则建议从布局管理器添加子项组件,
而不是直接调用容器add方法, 其它子项变更操作(remove, insert)同理.
如果layoutOnChange为true,组件加入后将重新布局容器,否则只调用layoutChild对加入组件进行布局.<div class="mdetail-params"><strong>Parameters:</strong><ul><li><code>component</code> : CC.Base<div class="sub-desc"></div></li><li><code>cfg</code> : Object<div class="sub-desc">组件布局信息</div></li></ul><strong>Returns:</strong><ul><li><code>this</code><div class="sub-desc"></div></li></ul></div></div></div></td><td class="msource"><a href="output/CC.layout.Layout.html#add" ext:member="#add" ext:cls="CC.layout.Layout">Layout</a></td></tr><tr class="method-row expandable inherited"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-display"></a><b><a href="source/cicylib-all.html#method-CC.layout.Layout-display">display</a></b>(&nbsp;<code>CC.Base&nbsp;component</code>,&nbsp;<code>Boolean&nbsp;displayOrNot</code>&nbsp;)
    :
                                        void<div class="mdesc"><div class="short">显示/隐藏子项,如果layoutOnChange为true则重新布局容器.</div><div class="long">显示/隐藏子项,如果layoutOnChange为true则重新布局容器.<div class="mdetail-params"><strong>Parameters:</strong><ul><li><code>component</code> : CC.Base<div class="sub-desc"></div></li><li><code>displayOrNot</code> : Boolean<div class="sub-desc"></div></li></ul><strong>Returns:</strong><ul><li>void</li></ul></div></div></div></td><td class="msource"><a href="output/CC.layout.Layout.html#display" ext:member="#display" ext:cls="CC.layout.Layout">Layout</a></td></tr><tr class="method-row expandable inherited"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-doLayout"></a><b><a href="source/cicylib-all.html#method-CC.layout.Layout-doLayout">doLayout</a></b>()
    :
                                        void<div class="mdesc"><div class="short">布局容器,要重写布局应重写onLayout方法.</div><div class="long">布局容器,要重写布局应重写onLayout方法.<div class="mdetail-params"><strong>Parameters:</strong><ul><li>None.</li></ul><strong>Returns:</strong><ul><li>void</li></ul></div></div></div></td><td class="msource"><a href="output/CC.layout.Layout.html#doLayout" ext:member="#doLayout" ext:cls="CC.layout.Layout">Layout</a></td></tr><tr class="method-row expandable inherited"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-cfgFrom"></a><b><a href="source/cicylib-all.html#method-CC.layout.Layout-cfgFrom">cfgFrom</a></b>(&nbsp;<code>CC.Base&nbsp;item</code>&nbsp;)
    :
                                        Object<div class="mdesc"><div class="short">获得控件当前布局相关的属性配置信息, 该调用无论任何时候都会返回一个非null对象,即使相关配置不存在.&#13;
var item = ct.$(0);&#13;
   var layout = ct.layout;&#13;
   var cfg = l...</div><div class="long">获得控件当前布局相关的属性配置信息, 该调用无论任何时候都会返回一个非null对象,即使相关配置不存在.
<pre><code><b>var</b> item = ct.$(0);
   <b>var</b> layout = ct.layout;
   <b>var</b> cfg = layout.cfgFrom(item);

   <b>if</b>(cfg.collapsed) {
    <i>//...</i>
   }</code></pre><div class="mdetail-params"><strong>Parameters:</strong><ul><li><code>item</code> : CC.Base<div class="sub-desc"></div></li></ul><strong>Returns:</strong><ul><li><code>Object</code><div class="sub-desc">控件当前布局相关的属性配置信息</div></li></ul></div></div></div></td><td class="msource"><a href="output/CC.layout.Layout.html#cfgFrom" ext:member="#cfgFrom" ext:cls="CC.layout.Layout">Layout</a></td></tr><tr class="method-row expandable inherited"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-fromArray"></a><b><a href="source/cicylib-all.html#method-CC.layout.Layout-fromArray">fromArray</a></b>(&nbsp;<code>CC.Base&nbsp;items</code>&nbsp;)
    :
                                        void<div class="mdesc"><div class="short">批量添加子控件到容器.</div><div class="long">批量添加子控件到容器.<div class="mdetail-params"><strong>Parameters:</strong><ul><li><code>items</code> : CC.Base<div class="sub-desc"></div></li></ul><strong>Returns:</strong><ul><li>void</li></ul></div></div></div></td><td class="msource"><a href="output/CC.layout.Layout.html#fromArray" ext:member="#fromArray" ext:cls="CC.layout.Layout">Layout</a></td></tr><tr class="method-row expandable inherited"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-attach"></a><b><a href="source/cicylib-all.html#method-CC.layout.Layout-attach">attach</a></b>(&nbsp;<code>Object&nbsp;ct</code>&nbsp;)
    :
                                        this<div class="mdesc"><div class="short">将布局管理器应用到一个容器控件中。</div><div class="long">将布局管理器应用到一个容器控件中。<div class="mdetail-params"><strong>Parameters:</strong><ul><li><code>ct</code> : Object<div class="sub-desc">container component</div></li></ul><strong>Returns:</strong><ul><li><code>this</code><div class="sub-desc"></div></li></ul></div></div></div></td><td class="msource"><a href="output/CC.layout.Layout.html#attach" ext:member="#attach" ext:cls="CC.layout.Layout">Layout</a></td></tr><tr class="method-row expandable inherited"><td class="micon"><a href="#expand" class="exi">&nbsp;</a></td><td class="sig"><a id="CC.layout.Layout-detach"></a><b><a href="source/cicylib-all.html#method-CC.layout.Layout-detach">detach</a></b>()
    :
                                        void<div class="mdesc"><div class="short">移除容器的布局管理器.</div><div class="long">移除容器的布局管理器.<div class="mdetail-params"><strong>Parameters:</strong><ul><li>None.</li></ul><strong>Returns:</strong><ul><li>void</li></ul></div></div></div></td><td class="msource"><a href="output/CC.layout.Layout.html#detach" ext:member="#detach" ext:cls="CC.layout.Layout">Layout</a></td></tr></tbody></table></div>